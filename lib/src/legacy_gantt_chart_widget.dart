// packages/gantt_chart/lib/src/gantt_chart_widget.dart
import 'package:flutter/material.dart';
import 'package:flutter/gestures.dart';
import 'package:legacy_gantt_chart/src/models/legacy_gantt_dependency.dart';
import 'package:flutter/scheduler.dart';
import 'package:provider/provider.dart';
import 'models/legacy_gantt_task.dart';
import 'models/legacy_gantt_theme.dart';
import 'models/legacy_gantt_row.dart';
import 'axis_painter.dart';
import 'legacy_gantt_controller.dart';
import 'legacy_gantt_view_model.dart';
import 'bars_collection_painter.dart';
import 'sync/gantt_sync_client.dart';
import 'cursor_painter.dart';

/// Defines the type of progress indicator to display during loading.
enum GanttLoadingIndicatorType {
  /// A circular progress indicator in the center of the chart.
  circular,

  /// A linear progress indicator at the top or bottom of the chart.
  linear,
}

/// Defines the position for the linear progress indicator.
enum GanttLoadingIndicatorPosition {
  /// Positions the linear indicator at the top of the chart area.
  top,

  /// Positions the linear indicator at the bottom of the chart area.
  bottom,
}

/// The main widget for displaying a Gantt chart.
///
/// This widget is responsible for rendering the timeline, task bars, and dependencies.
/// It handles user interactions such as dragging, resizing, and creating tasks and dependencies.
///
/// It can be used with a static list of data or dynamically with a [LegacyGanttController].
class LegacyGanttChartWidget extends StatefulWidget {
  /// The list of [LegacyGanttTask] objects to display on the chart.
  /// This is ignored if a [controller] or [tasksFuture] is provided.
  final List<LegacyGanttTask>? data;

  /// A list of dependencies to draw between tasks.
  /// This is ignored if a [controller] is provided.
  final List<LegacyGanttTaskDependency>? dependencies;

  /// A list of conflict indicators to draw on the chart. These are typically
  /// generated by a conflict detection algorithm.
  final List<LegacyGanttTask>? conflictIndicators;

  /// A list of tasks to be rendered as background highlights, such as holidays
  /// or weekends. These tasks should have `isTimeRangeHighlight` set to `true`.
  /// This is ignored if a [controller] is provided.
  final List<LegacyGanttTask>? holidays;

  /// The list of [LegacyGanttRow]s that are currently visible in the chart's viewport.
  /// This is used to determine which rows to render.
  final List<LegacyGanttRow> visibleRows;

  /// A callback function invoked when the user's cursor hovers over a task.
  ///
  /// Provides the [LegacyGanttTask] being hovered and the global position of the cursor.
  /// Useful for showing custom tooltips or hover effects.
  final Function(LegacyGanttTask?, Offset globalPosition)? onTaskHover;

  /// A scroll controller for the vertical scrolling of the Gantt chart.
  ///
  /// This should be the same controller used by an accompanying data grid (e.g., `GanttGrid`)
  /// to ensure that the chart and the grid scroll in sync.
  final ScrollController? scrollController;

  /// The height of the timeline axis header at the top of the chart.
  final double? axisHeight;

  /// Defines the height of each row based on task overlaps.
  ///
  /// This map keys a [LegacyGanttRow.id] to an integer representing the maximum
  /// number of concurrent tasks to display vertically in that row.
  ///
  /// * **Calculation:** The total height for a given row is calculated as
  ///   `rowHeight * rowMaxStackDepth[rowId]`.
  /// * **Conflicts:** If more tasks overlap than this value allows, the chart
  ///   will render a conflict indicator (a red, patterned bar) if `showConflicts` is enabled.
  final Map<String, int> rowMaxStackDepth;

  /// The height of a single task bar lane within a row. The total height of a
  /// [LegacyGanttRow] is `rowHeight * stackDepth`.
  final double rowHeight;

  /// The theme data that defines the colors and styles for the chart's elements.
  /// If not provided, a default theme is derived from the ambient [ThemeData].
  final LegacyGanttTheme? theme;

  /// The start of the visible date range, expressed as milliseconds since the Unix epoch.
  ///
  /// This determines the leftmost edge of the chart's viewport.
  /// * If a [controller] is provided, this property is ignored as the controller manages the viewport.
  /// * If [gridMin] is null and no controller is used, the chart defaults to the earliest start date found in [data].
  final double? gridMin;

  /// The end of the visible date range, expressed as milliseconds since the Unix epoch.
  ///
  /// This determines the rightmost edge of the chart's viewport.
  /// * If a [controller] is provided, this property is ignored as the controller manages the viewport.
  /// * If [gridMax] is null and no controller is used, the chart defaults to the latest end date found in [data].
  final double? gridMax;

  /// The absolute start of the entire possible date range for the chart.
  /// This is used by the timeline axis to determine its overall width.
  final double? totalGridMin; // The start of the entire dataset's time range

  /// The absolute end of the entire possible date range for the chart.
  final double? totalGridMax; // The end of the entire dataset's time range

  /// A callback function invoked when a user taps or clicks on a task bar.
  final Function(LegacyGanttTask)? onPressTask;

  /// Enables or disables the ability to drag and drop tasks to change their time or row.
  final bool enableDragAndDrop;

  /// Enables or disables the ability to resize tasks by dragging their start or end handles.
  final bool enableResize;

  /// A future that resolves to the list of tasks to display.
  /// This is ignored if a [controller] is provided.
  final Future<List<LegacyGanttTask>>? tasksFuture;

  /// A future that resolves to a list of holiday/highlight tasks.
  /// This is ignored if a [controller] is provided.
  final Future<List<LegacyGanttTask>>? holidaysFuture;

  /// A controller to programmatically manage the Gantt chart's state, including
  /// the visible date range and dynamically loaded data. When a controller is
  /// provided, properties like `data`, `holidays`, `gridMin`, and `gridMax` are
  /// ignored as they are managed by the controller.
  final LegacyGanttController? controller;

  /// A builder function to create a completely custom widget for a task bar.
  ///
  /// If this is provided, the default task bar painting is skipped, and this widget is
  /// rendered instead. This gives full control over the appearance and behavior of a task.
  /// This cannot be used simultaneously with [taskContentBuilder].
  final Widget Function(LegacyGanttTask task)? taskBarBuilder;

  /// A builder to create custom content *inside* the default task bar.
  ///
  /// This is useful for adding custom icons, text, or progress indicators while
  /// retaining the default bar's shape, color, and drag/resize handles.
  /// This cannot be used simultaneously with [taskBarBuilder].
  final Widget Function(LegacyGanttTask task)? taskContentBuilder;

  /// A callback function that is invoked when a task is updated through dragging or resizing.
  ///
  /// Provides the updated [LegacyGanttTask] and its new `start` and `end` times.
  final Function(LegacyGanttTask task, DateTime newStart, DateTime newEnd)? onTaskUpdate;

  /// A callback function invoked when a user double-taps or double-clicks on a task bar.
  ///
  /// Provides the [LegacyGanttTask] that was double-tapped.
  final Function(LegacyGanttTask task)? onTaskDoubleClick;

  /// A callback function that is invoked when a task is deleted.
  final Function(LegacyGanttTask task)? onTaskDelete;

  /// A function to format the date/time shown in the tooltip when resizing a task.
  final String Function(DateTime)? resizeTooltipDateFormat;

  /// A callback that is triggered when a user clicks on an empty space in the
  /// chart. This can be used to initiate the creation of a new task.
  final Function(String rowId, DateTime time)? onEmptySpaceClick;

  /// The background color of the tooltip that appears during drag or resize operations.
  /// If not provided, it defaults to the theme's `barColorPrimary`.
  final Color? resizeTooltipBackgroundColor;

  /// The font color of the tooltip that appears during drag or resize operations.
  /// If not provided, it's automatically determined for contrast against the
  /// tooltip's background color.
  final Color? resizeTooltipFontColor;

  /// The width of the resize handles at the start and end of a task bar.
  final double resizeHandleWidth;

  /// A builder function to customize the labels displayed on the timeline axis.
  ///
  /// This function is called for each label on the timeline and provides the
  /// [DateTime] of the label and the current [Duration] of the tick interval.
  /// This allows for flexible formatting, such as displaying month names,
  /// fiscal year quarters, or any other custom representation.
  ///
  /// Example:
  /// ```dart
  /// timelineAxisLabelBuilder: (DateTime date, Duration interval) {
  ///   if (interval.inDays > 20) {
  ///     return DateFormat('MMM yyyy').format(date); // Display month and year
  ///   } else {
  ///     return DateFormat('d MMM').format(date); // Display day and month
  ///   }
  /// }
  /// ```
  final String Function(DateTime, Duration)? timelineAxisLabelBuilder;

  /// A builder function to create a completely custom widget for the timeline header.
  ///
  /// If this is provided, the default timeline header painting is skipped, and this
  /// widget is rendered instead. This gives you full control over the appearance
  /// and behavior of the timeline header.
  ///
  /// The builder provides the following arguments:
  /// - `context`: The build context.
  /// - `scale`: A function that converts a `DateTime` to its corresponding horizontal (x-axis) pixel value.
  /// - `visibleDomain`: The currently visible date range.
  /// - `totalDomain`: The total date range of the entire chart.
  /// - `theme`: The current Gantt chart theme.
  /// - `totalContentWidth`: The total width of the chart's content area.
  final Widget Function(
    BuildContext context,
    double Function(DateTime) scale,
    List<DateTime> visibleDomain,
    List<DateTime> totalDomain,
    LegacyGanttTheme theme,
    double totalContentWidth,
  )? timelineAxisHeaderBuilder;

  /// A builder function to create a custom widget to display when there is no data.
  ///
  /// If not provided, a default message will be shown.
  final Widget Function(BuildContext context)? noDataWidgetBuilder;

  /// If set to `true`, the chart will display the empty rows provided via
  /// [visibleRows] even when there are no tasks.
  ///
  /// Defaults to `false`, which shows the [noDataWidgetBuilder] or a default "No data to display" message.
  final bool showEmptyRows;

  /// An optional fixed height for the Gantt chart widget.
  ///
  /// If provided, the widget will render with this explicit height. This is
  /// particularly useful when placing the Gantt chart inside a `SingleChildScrollView`
  /// to make it vertically scrollable. The user is responsible for calculating
  /// the appropriate height based on the number of rows and their content.
  ///
  /// If `null`, the widget will attempt to size itself based on the available
  /// constraints, either expanding to fill a parent (like `Expanded`) or
  /// calculating its intrinsic height if given unconstrained vertical space.
  final double? height;

  /// The type of progress indicator to display when loading data with a [controller].
  ///
  /// Defaults to [GanttLoadingIndicatorType.circular].
  final GanttLoadingIndicatorType loadingIndicatorType;

  /// The position of the [GanttLoadingIndicatorType.linear] progress indicator.
  ///
  /// This is only applicable if [loadingIndicatorType] is set to
  /// [GanttLoadingIndicatorType.linear].
  /// Defaults to [GanttLoadingIndicatorPosition.top].
  final GanttLoadingIndicatorPosition loadingIndicatorPosition;

  /// The height of the loading indicator when using [GanttLoadingIndicatorType.linear].
  /// Defaults to `4.0`.
  final double loadingIndicatorHeight;

  /// The days of the week to be highlighted as weekends.
  ///
  /// This list should contain integers representing the days of the week,
  /// where Monday is 1 and Sunday is 7.
  /// Defaults to [DateTime.saturday] and [DateTime.sunday].
  final List<int> weekendDays;

  /// The color used to highlight weekends in the chart background.
  ///
  /// If not provided, it defaults to a semi-transparent shade of the
  /// theme's `onSurface` color.
  /// The color used to highlight weekends in the chart background.
  ///
  /// If not provided, it defaults to a semi-transparent shade of the
  /// theme's `onSurface` color.
  final Color? weekendColor;

  /// The synchronization client for multiplayer features.
  final GanttSyncClient? syncClient;

  /// A function to group tasks for conflict detection.
  final Object? Function(LegacyGanttTask task)? taskGrouper;

  /// A scroll controller for the horizontal scrolling of the Gantt chart.
  /// This is used internally to allow programmatic scrolling, for example,
  /// to bring a focused task into view.
  final ScrollController? horizontalScrollController;

  /// A callback invoked when an action (like focusing a task via keyboard)
  /// requires a row to become visible (e.g., by expanding a collapsed parent).
  /// The consumer of this widget is responsible for updating its state to make the row visible.
  final Function(String rowId)? onRowRequestVisible;

  /// The ID of the task that currently has keyboard focus.
  final String? focusedTaskId;

  /// A callback invoked when the focused task changes due to user interaction.
  final Function(String? taskId)? onFocusChange;

  /// A builder function to create custom resize handles that appear next to a focused task.
  ///
  /// The builder provides the `task` and a `part` enum (`TaskPart.startHandle` or `TaskPart.endHandle`)
  /// to allow for different widgets for the start and end handles. If this is `null`, no
  /// external handles are shown for focused tasks.
  final Widget Function(LegacyGanttTask task, TaskPart part, LegacyGanttViewModel vm, double handleWidth)?
      focusedTaskResizeHandleBuilder;

  /// The width of the floating resize handles that appear on a focused task.
  /// This value is passed to the [focusedTaskResizeHandleBuilder]. Defaults to `24.0`.
  final double focusedTaskResizeHandleWidth;

  /// Whether to show cursors from other users when connected via [syncClient].
  final bool showCursors;

  const LegacyGanttChartWidget({
    super.key, // Use super.key
    this.data,
    this.dependencies,
    this.conflictIndicators,
    this.holidays,
    required this.visibleRows,
    required this.rowMaxStackDepth,
    this.onTaskHover,
    this.scrollController,
    this.axisHeight,
    this.rowHeight = 27.0,
    this.onPressTask,
    this.theme,
    this.gridMin,
    this.gridMax,
    this.totalGridMin,
    this.totalGridMax,
    this.enableDragAndDrop = false,
    this.enableResize = false,
    this.tasksFuture,
    this.holidaysFuture,
    this.controller,
    this.taskBarBuilder,
    this.taskContentBuilder,
    this.onTaskUpdate,
    this.onTaskDoubleClick,
    this.onTaskDelete,
    this.resizeTooltipDateFormat,
    this.onEmptySpaceClick,
    this.resizeTooltipBackgroundColor,
    this.resizeTooltipFontColor,
    this.resizeHandleWidth = 10.0,
    this.timelineAxisLabelBuilder,
    this.timelineAxisHeaderBuilder,
    this.noDataWidgetBuilder,
    this.showEmptyRows = false,
    this.height,
    this.loadingIndicatorType = GanttLoadingIndicatorType.circular,
    this.loadingIndicatorPosition = GanttLoadingIndicatorPosition.top,
    this.loadingIndicatorHeight = 4.0,
    this.weekendDays = const [DateTime.saturday, DateTime.sunday],
    this.weekendColor,
    this.onRowRequestVisible,
    this.focusedTaskId,
    this.onFocusChange,
    this.horizontalScrollController,
    this.focusedTaskResizeHandleBuilder,
    this.focusedTaskResizeHandleWidth = 24.0,
    this.syncClient,
    this.taskGrouper,
    this.showCursors = true,
  })  : assert(controller != null || ((data != null && tasksFuture == null) || (data == null && tasksFuture != null))),
        assert(controller == null || dependencies == null),
        assert(taskBarBuilder == null || taskContentBuilder == null),
        assert(controller == null || conflictIndicators == null),
        assert(controller == null ||
            (data == null &&
                tasksFuture == null &&
                holidays == null &&
                holidaysFuture == null &&
                gridMin == null &&
                gridMax == null));

  @override
  State<LegacyGanttChartWidget> createState() => _LegacyGanttChartWidgetState();
}

class _LegacyGanttChartWidgetState extends State<LegacyGanttChartWidget> {
  // A direct reference to the internal view model is needed to push updates
  // when the widget's properties change.
  LegacyGanttViewModel? _internalViewModel;

  @override
  void didUpdateWidget(covariant LegacyGanttChartWidget oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (_internalViewModel != null) {
      _internalViewModel!.updateDependencies(widget.dependencies ?? []);

      if (oldWidget.showCursors != widget.showCursors) {
        _internalViewModel!.showRemoteCursors = widget.showCursors;
      }

      final List<LegacyGanttTask> allItems = [...(widget.data ?? []), ...(widget.holidays ?? [])];
      _internalViewModel!.updateData(allItems);

      if (widget.conflictIndicators != null) {
        _internalViewModel!.updateConflictIndicators(widget.conflictIndicators!);
      }

      _internalViewModel!.updateVisibleRows(widget.visibleRows);

      _internalViewModel!.updateRowMaxStackDepth(widget.rowMaxStackDepth);

      if (oldWidget.axisHeight != widget.axisHeight) {
        _internalViewModel!.updateAxisHeight(widget.axisHeight);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final LegacyGanttTheme effectiveTheme =
        (widget.theme ?? LegacyGanttTheme.fromTheme(theme)).copyWith(weekendColor: widget.weekendColor);

    if (widget.controller != null) {
      return _wrap(AnimatedBuilder(
        animation: widget.controller!,
        builder: (context, child) {
          final controller = widget.controller!;
          final tasks = controller.tasks;
          final holidays = controller.holidays;
          final dependencies = controller.dependencies;
          final conflictIndicators = controller.conflictIndicators;
          final allItems = [...tasks, ...holidays]; // Conflicts are handled separately

          // Push updates to internal view model
          if (_internalViewModel != null) {
            _internalViewModel!.updateData(allItems);
            _internalViewModel!.updateDependencies(dependencies);
            _internalViewModel!.updateConflictIndicators(conflictIndicators);
            _internalViewModel!.updateVisibleRange(controller.visibleStartDate.millisecondsSinceEpoch.toDouble(),
                controller.visibleEndDate.millisecondsSinceEpoch.toDouble());
          }

          if (controller.isOverallLoading && allItems.isEmpty && !widget.showEmptyRows) {
            if (widget.loadingIndicatorType == GanttLoadingIndicatorType.circular) {
              return const Center(child: CircularProgressIndicator());
            } else {
              return SizedBox(height: widget.loadingIndicatorHeight, child: const LinearProgressIndicator());
            }
          }

          if (allItems.isEmpty && !controller.isOverallLoading && !widget.showEmptyRows) {
            if (widget.noDataWidgetBuilder != null) {
              return widget.noDataWidgetBuilder!(context);
            } else {
              return Center(
                child: Text('No data to display.', style: TextStyle(color: effectiveTheme.textColor)),
              );
            }
          }

          return Stack(
            children: [
              _buildChart(
                context,
                allItems,
                dependencies,
                conflictIndicators,
                effectiveTheme,
                gridMin: controller.visibleStartDate.millisecondsSinceEpoch.toDouble(),
                gridMax: controller.visibleEndDate.millisecondsSinceEpoch.toDouble(),
                currentTool: controller.currentTool,
              ),
              if (controller.isLoading && widget.loadingIndicatorType == GanttLoadingIndicatorType.linear)
                Positioned(
                  left: 0,
                  right: 0,
                  top: widget.loadingIndicatorPosition == GanttLoadingIndicatorPosition.top ? 0 : null,
                  bottom: widget.loadingIndicatorPosition == GanttLoadingIndicatorPosition.bottom ? 0 : null,
                  child: SizedBox(height: widget.loadingIndicatorHeight, child: const LinearProgressIndicator()),
                ),
              if (controller.isLoading && widget.loadingIndicatorType == GanttLoadingIndicatorType.circular)
                Positioned.fill(
                  child: Container(
                    color: effectiveTheme.backgroundColor.withValues(alpha: 0.5),
                    child: const Center(child: CircularProgressIndicator()),
                  ),
                ),
            ],
          );
        },
      ));
    }

    if (widget.tasksFuture != null || widget.holidaysFuture != null) {
      return _wrap(FutureBuilder<List<dynamic>>(
        future: Future.wait([
          widget.tasksFuture ?? Future.value(<LegacyGanttTask>[]),
          widget.holidaysFuture ?? Future.value(<LegacyGanttTask>[])
        ]),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }
          if (snapshot.hasError) {
            return Center(child: Text('Error: ${snapshot.error}'));
          }
          final tasks = (snapshot.data?[0] as List<LegacyGanttTask>?) ?? [];
          final holidays = (snapshot.data?[1] as List<LegacyGanttTask>?) ?? [];
          final allItems = [...tasks, ...holidays];
          // Conflicts are derived from tasks, so we pass them separately.
          final conflictIndicators = widget.conflictIndicators ?? [];
          if (allItems.isEmpty && !widget.showEmptyRows) {
            if (widget.noDataWidgetBuilder != null) {
              return widget.noDataWidgetBuilder!(context);
            } else {
              return Center(
                child: Text('No data to display.', style: TextStyle(color: effectiveTheme.textColor)),
              );
            }
          }
          return _wrap(_buildChart(context, allItems, widget.dependencies ?? [], conflictIndicators, effectiveTheme));
        },
      ));
    } else {
      final tasks = widget.data ?? [];
      final holidays = widget.holidays ?? [];
      final conflictIndicators = widget.conflictIndicators ?? [];
      final allItems = [...tasks, ...holidays];
      if (allItems.isEmpty && !widget.showEmptyRows) {
        if (widget.noDataWidgetBuilder != null) {
          return _wrap(widget.noDataWidgetBuilder!(context));
        } else {
          return _wrap(Center(
            child: Text('No data to display.', style: TextStyle(color: effectiveTheme.textColor)),
          ));
        }
      }
      return _wrap(_buildChart(context, allItems, widget.dependencies ?? [], conflictIndicators, effectiveTheme));
    }
  }

  Widget _buildChart(BuildContext context, List<LegacyGanttTask> tasks, List<LegacyGanttTaskDependency> dependencies,
          List<LegacyGanttTask> conflictIndicators, LegacyGanttTheme effectiveTheme,
          {double? gridMin, double? gridMax, GanttTool currentTool = GanttTool.move}) =>
      ChangeNotifierProvider<LegacyGanttViewModel>(
        key: ValueKey(widget.syncClient),
        create: (context) {
          _internalViewModel = LegacyGanttViewModel(
            data: tasks,
            conflictIndicators: conflictIndicators,
            dependencies: dependencies,
            visibleRows: widget.visibleRows,
            rowMaxStackDepth: widget.rowMaxStackDepth,
            rowHeight: widget.rowHeight,
            axisHeight: widget.axisHeight,
            gridMin: gridMin ?? widget.gridMin,
            gridMax: gridMax ?? widget.gridMax,
            totalGridMin: widget.totalGridMin,
            totalGridMax: widget.totalGridMax,
            enableDragAndDrop: widget.enableDragAndDrop,
            enableResize: widget.enableResize,
            onTaskUpdate: widget.onTaskUpdate,
            onTaskDoubleClick: widget.onTaskDoubleClick,
            onTaskDelete: widget.onTaskDelete,
            onEmptySpaceClick: widget.onEmptySpaceClick,
            onPressTask: widget.onPressTask,
            onTaskHover: widget.onTaskHover,
            taskBarBuilder: widget.taskBarBuilder,
            resizeTooltipDateFormat: widget.resizeTooltipDateFormat,
            scrollController: widget.scrollController,
            ganttHorizontalScrollController: widget.horizontalScrollController,
            onRowRequestVisible: widget.onRowRequestVisible,
            initialFocusedTaskId: widget.focusedTaskId,
            onFocusChange: widget.onFocusChange,
            resizeHandleWidth: widget.resizeHandleWidth,
            syncClient: widget.syncClient,
            taskGrouper: widget.taskGrouper,
            onVisibleRangeChanged: (start, end) {
              if (widget.controller != null) {
                if (widget.controller!.visibleStartDate != start || widget.controller!.visibleEndDate != end) {
                  widget.controller!.setVisibleRange(start, end);
                }
              }
            },
            onSelectionChanged: (ids) {
              if (widget.controller != null) {
                widget.controller!.setSelectedTaskIds(ids);
              }
            },
          )..showRemoteCursors = widget.showCursors;
          return _internalViewModel!;
        },
        child: Consumer<LegacyGanttViewModel>(
          builder: (context, vm, child) {
            // Force update of view model properties that might have changed
            // This is a bit of a hack to ensure the VM is up to date with the widget
            // Ideally we would trigger updates via `didUpdateWidget`, which we do, but
            // this ensures it happens within the build cycle if needed.
            // Actually, `didUpdateWidget` handles most updates.
            // The postFrameCallback handles updates that depend on layout or focus.
            SchedulerBinding.instance.addPostFrameCallback((_) {
              if (!vm.isDisposed) {
                vm.updateVisibleRange(gridMin ?? widget.gridMin, gridMax ?? widget.gridMax);
                vm.updateFocusedTask(widget.focusedTaskId);
                vm.updateResizeTooltipDateFormat(widget.resizeTooltipDateFormat);
                vm.setTool(currentTool);
              }
            });

            return Column(
              children: [
                // Toolbar
                Expanded(
                  child: LayoutBuilder(
                    builder: (BuildContext context, BoxConstraints constraints) {
                      if (constraints.maxWidth == 0 || constraints.maxHeight == 0) {
                        return const SizedBox.shrink();
                      }

                      vm.updateLayout(constraints.maxWidth, constraints.maxHeight);

                      final double totalContentWidth =
                          vm.totalDomain.isEmpty ? constraints.maxWidth : vm.totalScale(vm.totalDomain.last);

                      final double totalContentHeight =
                          (widget.showEmptyRows ? widget.visibleRows.map((r) => r.id) : vm.data.map((t) => t.rowId))
                              .toSet()
                              .fold<double>(
                                0.0,
                                (prev, rowId) => prev + widget.rowHeight * (widget.rowMaxStackDepth[rowId] ?? 1),
                              );

                      final bool useIntrinsicHeight = !constraints.maxHeight.isFinite;
                      final double chartHeight;

                      if (widget.height != null) {
                        chartHeight = widget.height!;
                      } else if (useIntrinsicHeight) {
                        chartHeight = vm.timeAxisHeight + totalContentHeight;
                      } else {
                        chartHeight = constraints.maxHeight;
                      }
                      final double contentHeight = chartHeight - vm.timeAxisHeight;

                      return Listener(
                        onPointerSignal: (event) {
                          if (event is PointerScrollEvent) {
                            if (event.scrollDelta.dx != 0) {
                              vm.onHorizontalScroll(event.scrollDelta.dx);
                            }
                            if (event.scrollDelta.dy != 0) {
                              if (vm.scrollController != null && vm.scrollController!.hasClients) {
                                final newOffset = vm.scrollController!.offset + event.scrollDelta.dy;
                                vm.scrollController!.jumpTo(newOffset.clamp(
                                    vm.scrollController!.position.minScrollExtent,
                                    vm.scrollController!.position.maxScrollExtent));
                              }
                            }
                          }
                        },
                        child: GestureDetector(
                          onPanStart: (details) => vm.onPanStart(details),
                          onPanUpdate: (details) => vm.onPanUpdate(details),
                          onPanEnd: (details) => vm.onPanEnd(details),
                          onTapDown: (details) => vm.onTapDown(details),
                          onTap: () => vm.onTap(),
                          onDoubleTapDown: (details) => vm.onDoubleTap(details.localPosition),
                          child: MouseRegion(
                            cursor: vm.cursor,
                            onHover: (event) => vm.onHover(event),
                            onExit: (event) => vm.onHoverExit(event),
                            child: ClipRect(
                              child: Stack(
                                children: [
                                  // 1. Chart Content Area (Grid, Bars, Tasks, Cursors)
                                  Padding(
                                    padding: EdgeInsets.only(top: vm.timeAxisHeight),
                                    child: Stack(
                                      children: [
                                        // 1.1 Grid Painter (Background)
                                        RepaintBoundary(
                                          child: CustomPaint(
                                            size: Size(constraints.maxWidth, constraints.maxHeight - vm.timeAxisHeight),
                                            painter: AxisPainter(
                                              x: 0,
                                              y: 0,
                                              width: totalContentWidth,
                                              height: contentHeight,
                                              scale: vm.totalScale,
                                              domain: vm.totalDomain,
                                              visibleDomain: vm.visibleExtent,
                                              theme: effectiveTheme.copyWith(
                                                  axisTextStyle: const TextStyle(color: Colors.transparent)),
                                              weekendColor: effectiveTheme.weekendColor,
                                              weekendDays: widget.weekendDays,
                                            ),
                                          ),
                                        ),
                                        // 1.2 Bars Painter (Main Content)
                                        RepaintBoundary(
                                          child: CustomPaint(
                                            size: Size(constraints.maxWidth, constraints.maxHeight - vm.timeAxisHeight),
                                            painter: BarsCollectionPainter(
                                              conflictIndicators: vm.conflictIndicators,
                                              dependencies: vm.dependencies,
                                              data: vm.data,
                                              domain: vm.totalDomain,
                                              visibleRows: widget.visibleRows,
                                              rowMaxStackDepth: widget.rowMaxStackDepth,
                                              scale: vm.totalScale,
                                              rowHeight: widget.rowHeight,
                                              draggedTaskId: vm.draggedTask?.id,
                                              ghostTaskStart: vm.ghostTaskStart,
                                              ghostTaskEnd: vm.ghostTaskEnd,
                                              remoteGhosts: vm.remoteGhosts,
                                              theme: effectiveTheme,
                                              hoveredRowId: vm.hoveredRowId,
                                              hoveredDate: vm.hoveredDate,
                                              hasCustomTaskBuilder: widget.taskBarBuilder != null,
                                              hasCustomTaskContentBuilder: widget.taskContentBuilder != null,
                                              translateY: vm.translateY,
                                              selectedTaskIds: vm.selectedTaskIds,
                                              bulkGhostTasks: vm.bulkGhostTasks,
                                            ),
                                          ),
                                        ),
                                        // 1.3 Selection Box Painter
                                        if (vm.currentTool == GanttTool.select && vm.selectionRect != null)
                                          CustomPaint(
                                            size: Size(constraints.maxWidth, constraints.maxHeight - vm.timeAxisHeight),
                                            painter: _SelectionBoxPainter(
                                              rect: vm.selectionRect!,
                                              borderColor: Theme.of(context).primaryColor,
                                              fillColor: Theme.of(context).primaryColor.withValues(alpha: 0.2),
                                            ),
                                          ),
                                        // 1.4 Custom Task Widgets
                                        if (widget.taskBarBuilder != null || widget.taskContentBuilder != null)
                                          ..._buildTaskWidgets(vm, vm.data, effectiveTheme),
                                        ..._buildCustomCellWidgets(vm, vm.data),
                                        ..._buildFocusedTaskWidgets(vm, vm.data, effectiveTheme,
                                            widget.focusedTaskResizeHandleBuilder, widget.focusedTaskResizeHandleWidth),
                                        // 1.5 Cursors
                                        if (vm.showRemoteCursors)
                                          IgnorePointer(
                                            child: RepaintBoundary(
                                              child: CustomPaint(
                                                size: Size(
                                                    constraints.maxWidth, constraints.maxHeight - vm.timeAxisHeight),
                                                painter: CursorPainter(
                                                  remoteCursors: vm.showRemoteCursors ? vm.remoteCursors : const {},
                                                  totalScale: vm.totalScale,
                                                  visibleRows: widget.visibleRows,
                                                  rowMaxStackDepth: widget.rowMaxStackDepth,
                                                  rowHeight: widget.rowHeight,
                                                  translateY: vm.translateY,
                                                ),
                                              ),
                                            ),
                                          ),
                                      ],
                                    ),
                                  ),

                                  // 2. Header Painter (Top Axis) - Fixed at Top
                                  Positioned(
                                    top: 0,
                                    left: 0,
                                    right: 0,
                                    height: vm.timeAxisHeight,
                                    child: widget.timelineAxisHeaderBuilder != null
                                        ? widget.timelineAxisHeaderBuilder!(
                                            context,
                                            vm.totalScale,
                                            vm.visibleExtent,
                                            vm.totalDomain,
                                            effectiveTheme,
                                            totalContentWidth,
                                          )
                                        : Container(
                                            color: effectiveTheme.backgroundColor,
                                            child: RepaintBoundary(
                                              child: CustomPaint(
                                                painter: AxisPainter(
                                                  x: 0,
                                                  y: 0,
                                                  width: totalContentWidth,
                                                  height: vm.timeAxisHeight,
                                                  scale: vm.totalScale,
                                                  domain: vm.totalDomain,
                                                  visibleDomain: vm.visibleExtent,
                                                  theme: effectiveTheme,
                                                  timelineAxisLabelBuilder: widget.timelineAxisLabelBuilder,
                                                  weekendColor: effectiveTheme.weekendColor,
                                                  weekendDays: widget.weekendDays,
                                                  showGridLines: false,
                                                  verticallyCenterLabels: true,
                                                ),
                                              ),
                                            ),
                                          ),
                                  ),

                                  // 3. Resize Tooltip - Absolute Position
                                  if (vm.showResizeTooltip)
                                    Positioned(
                                      left: vm.resizeTooltipPosition.dx + 15,
                                      top: vm.resizeTooltipPosition.dy + 15,
                                      child: _buildResizeTooltip(context, vm.resizeTooltipText, effectiveTheme),
                                    ),
                                ],
                              ),
                            ),
                          ),
                        ),
                      );
                    },
                  ),
                ),
              ],
            );
          },
        ),
      );

  Widget _wrap(Widget child) {
    if (widget.height != null) {
      return SizedBox(height: widget.height, child: child);
    }
    return child;
  }

  Widget _buildResizeTooltip(BuildContext context, String text, LegacyGanttTheme theme) {
    final tooltipBackgroundColor = widget.resizeTooltipBackgroundColor ?? theme.barColorPrimary;
    final tooltipFontColor = widget.resizeTooltipFontColor ??
        (ThemeData.estimateBrightnessForColor(tooltipBackgroundColor) == Brightness.dark ? Colors.white : Colors.black);

    return Material(
      elevation: 4.0,
      borderRadius: BorderRadius.circular(4),
      color: Colors.transparent,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10.0, vertical: 6.0),
        decoration: BoxDecoration(color: tooltipBackgroundColor, borderRadius: BorderRadius.circular(4)),
        child: Text(
          text,
          style: theme.axisTextStyle.copyWith(color: tooltipFontColor),
        ),
      ),
    );
  }

  List<Widget> _buildTaskWidgets(LegacyGanttViewModel vm, List<LegacyGanttTask> tasks, LegacyGanttTheme theme) {
    final List<Widget> taskWidgets = [];
    double cumulativeRowTop = 0;

    final Map<String, List<LegacyGanttTask>> tasksByRow = {};
    final visibleRowIds = vm.visibleRows.map((r) => r.id).toSet();
    for (final task in tasks) {
      if (visibleRowIds.contains(task.rowId) && !task.isTimeRangeHighlight) {
        tasksByRow.putIfAbsent(task.rowId, () => []).add(task);
      }
    }

    for (final rowData in vm.visibleRows) {
      final tasksInThisRow = tasksByRow[rowData.id] ?? [];
      for (final task in tasksInThisRow) {
        final startX = vm.totalScale(task.start);
        final endX = vm.totalScale(task.end);
        final width = endX - startX;

        if (width <= 0) {
          continue;
        }

        final top = cumulativeRowTop + (task.stackIndex * vm.rowHeight) + vm.translateY;

        Widget taskWidget;
        if (task.isOverlapIndicator) {
          taskWidget = _OverlapIndicatorBar(theme: theme);
        } else if (widget.taskBarBuilder != null) {
          taskWidget = widget.taskBarBuilder!(task);
        } else {
          taskWidget = _DefaultTaskBar(
            task: task,
            vm: vm,
            theme: theme,
            content: widget.taskContentBuilder != null ? widget.taskContentBuilder!(task) : null,
          );
        }

        taskWidgets.add(Positioned(
          left: startX,
          top: top,
          width: width,
          height: vm.rowHeight,
          child: taskWidget,
        ));
      }
      final stackDepth = vm.rowMaxStackDepth[rowData.id] ?? 1;
      cumulativeRowTop += vm.rowHeight * stackDepth;
    }
    return taskWidgets;
  }

  List<Widget> _buildCustomCellWidgets(LegacyGanttViewModel vm, List<LegacyGanttTask> tasks) {
    final List<Widget> customCells = [];
    double cumulativeRowTop = 0;

    final Map<String, List<LegacyGanttTask>> tasksByRow = {};
    final visibleRowIds = vm.visibleRows.map((r) => r.id).toSet();
    for (final task in tasks) {
      if (visibleRowIds.contains(task.rowId) && task.cellBuilder != null) {
        tasksByRow.putIfAbsent(task.rowId, () => []).add(task);
      }
    }

    for (final rowData in vm.visibleRows) {
      final tasksInThisRow = tasksByRow[rowData.id] ?? [];
      for (final task in tasksInThisRow) {
        final taskStart = task.start;
        final taskEnd = task.end;

        var currentDate = DateTime(taskStart.year, taskStart.month, taskStart.day);
        while (currentDate.isBefore(taskEnd)) {
          final segmentStart = taskStart.isAfter(currentDate) ? taskStart : currentDate;
          final nextDay = currentDate.add(const Duration(days: 1));
          final segmentEnd = taskEnd.isBefore(nextDay) ? taskEnd : nextDay;

          final startX = vm.totalScale(segmentStart);
          final endX = vm.totalScale(segmentEnd);
          final width = endX - startX;

          if (width > 0) {
            final top = cumulativeRowTop + (task.stackIndex * vm.rowHeight) + vm.translateY;
            customCells.add(Positioned(
                left: startX, top: top, width: width, height: vm.rowHeight, child: task.cellBuilder!(currentDate)));
          }
          currentDate = nextDay;
        }
      }
      final stackDepth = vm.rowMaxStackDepth[rowData.id] ?? 1;
      cumulativeRowTop += vm.rowHeight * stackDepth;
    }
    return customCells;
  }
}

List<Widget> _buildFocusedTaskWidgets(
  LegacyGanttViewModel vm,
  List<LegacyGanttTask> tasks,
  LegacyGanttTheme theme,
  Widget Function(LegacyGanttTask, TaskPart, LegacyGanttViewModel, double)? handleBuilder,
  double handleWidth,
) {
  if (vm.focusedTaskId == null) return [];

  final focusedTask = tasks.firstWhere((t) => t.id == vm.focusedTaskId, orElse: () => LegacyGanttTask.empty());
  if (focusedTask.id.isEmpty) return [];

  // Find the row index and its vertical offset.
  final rowIndex = vm.visibleRows.indexWhere((r) => r.id == focusedTask.rowId);
  if (rowIndex == -1) return [];

  final rowTop = vm.getRowVerticalOffset(rowIndex);
  if (rowTop == null) return [];

  final startX = vm.totalScale(focusedTask.start);
  final endX = vm.totalScale(focusedTask.end);
  final width = endX - startX;
  final top = rowTop + (focusedTask.stackIndex * vm.rowHeight) + vm.translateY;

  final List<Widget> widgets = [
    Positioned(
      left: startX,
      top: top,
      width: width,
      height: vm.rowHeight,
      child: IgnorePointer(
        child: Container(
          decoration: BoxDecoration(
            border: Border.all(color: theme.barColorSecondary, width: 2),
            borderRadius: BorderRadius.circular(4.0),
          ),
        ),
      ),
    )
  ];

  // Add custom resize handles if a builder is provided
  if (handleBuilder != null) {
    final startHandle = handleBuilder(focusedTask, TaskPart.startHandle, vm, handleWidth);
    final endHandle = handleBuilder(focusedTask, TaskPart.endHandle, vm, handleWidth);

    widgets.addAll([
      Positioned(
        left: startX - handleWidth,
        top: top,
        height: vm.rowHeight,
        child: startHandle,
      ),
      Positioned(
        left: endX,
        top: top,
        height: vm.rowHeight,
        child: endHandle,
      ),
    ]);
  }

  return widgets;
}

class _DefaultTaskBar extends StatefulWidget {
  final LegacyGanttTask task;
  final LegacyGanttViewModel vm;
  final LegacyGanttTheme theme;
  final Widget? content;

  const _DefaultTaskBar({
    required this.task,
    required this.vm,
    required this.theme,
    this.content,
  });

  @override
  _DefaultTaskBarState createState() => _DefaultTaskBarState();
}

class _DefaultTaskBarState extends State<_DefaultTaskBar> {
  bool _isHovered = false;
  final FocusNode _focusNode = FocusNode();

  @override
  void dispose() {
    _focusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final task = widget.task;
    final theme = widget.theme;
    final vm = widget.vm;
    return Focus(
      focusNode: _focusNode,
      onFocusChange: (hasFocus) {
        if (hasFocus) {
          vm.setFocusedTask(task.id);
        }
      },
      child: MouseRegion(
        onEnter: (_) => setState(() => _isHovered = true),
        onExit: (_) => setState(() => _isHovered = false),
        child: Container(
          decoration: BoxDecoration(
            color: Colors.transparent,
            borderRadius: BorderRadius.circular(4.0),
          ),
          child: Stack(
            fit: StackFit.expand,
            children: [
              if (widget.content != null) widget.content!,
              if (_isHovered && vm.onTaskDelete != null)
                Positioned(
                  right: 0,
                  top: 0,
                  bottom: 0,
                  child: IconButton(
                    icon: const Icon(Icons.close, size: 16),
                    color: theme.taskTextStyle.color,
                    onPressed: () => vm.deleteTask(task),
                    splashRadius: 16,
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

/// A widget that uses a [CustomPainter] to draw the conflict/overlap pattern.
class _OverlapIndicatorBar extends StatelessWidget {
  final LegacyGanttTheme theme;

  const _OverlapIndicatorBar({required this.theme});

  @override
  Widget build(BuildContext context) => CustomPaint(
        painter: _OverlapPainter(theme: theme),
        child: Container(),
      );
}

/// The actual painter for the conflict/overlap pattern.
class _OverlapPainter extends CustomPainter {
  final LegacyGanttTheme theme;

  _OverlapPainter({required this.theme});

  @override
  void paint(Canvas canvas, Size size) {
    final barHeight = size.height * theme.barHeightRatio;
    final barVerticalCenterOffset = (size.height - barHeight) / 2;
    final fullRect = Rect.fromLTWH(0, barVerticalCenterOffset, size.width, barHeight);

    final indicatorHeight = fullRect.height * 0.4;
    final indicatorRect = Rect.fromLTWH(
      fullRect.left,
      fullRect.bottom - indicatorHeight,
      fullRect.width,
      indicatorHeight,
    );
    final indicatorRRect = RRect.fromRectAndRadius(indicatorRect, theme.barCornerRadius);

    canvas.drawRRect(indicatorRRect, Paint()..color = theme.backgroundColor);

    final backgroundPaint = Paint()..color = theme.conflictBarColor.withValues(alpha: 0.4);
    canvas.drawRRect(indicatorRRect, backgroundPaint);

    _drawAngledPattern(canvas, indicatorRRect, theme.conflictBarColor, 1.0);
  }

  void _drawAngledPattern(Canvas canvas, RRect rrect, Color color, double strokeWidth) {
    final patternPaint = Paint()
      ..color = color
      ..strokeWidth = strokeWidth
      ..style = PaintingStyle.stroke;

    canvas.save();
    canvas.clipRRect(rrect);

    const double lineSpacing = 8.0;
    for (double i = -rrect.height; i < rrect.width; i += lineSpacing) {
      canvas.drawLine(
          Offset(rrect.left + i, rrect.top), Offset(rrect.left + i + rrect.height, rrect.bottom), patternPaint);
    }
    canvas.restore();
  }

  @override
  bool shouldRepaint(covariant _OverlapPainter oldDelegate) => oldDelegate.theme != theme;
}

class _SelectionBoxPainter extends CustomPainter {
  final Rect rect;
  final Color borderColor;
  final Color fillColor;

  _SelectionBoxPainter({required this.rect, required this.borderColor, required this.fillColor});

  @override
  void paint(Canvas canvas, Size size) {
    canvas.drawRect(
      rect,
      Paint()
        ..color = fillColor
        ..style = PaintingStyle.fill,
    );
    canvas.drawRect(
      rect,
      Paint()
        ..color = borderColor
        ..style = PaintingStyle.stroke
        ..strokeWidth = 1,
    );
  }

  @override
  bool shouldRepaint(covariant _SelectionBoxPainter oldDelegate) =>
      rect != oldDelegate.rect || borderColor != oldDelegate.borderColor || fillColor != oldDelegate.fillColor;
}
