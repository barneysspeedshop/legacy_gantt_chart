// packages/gantt_chart/lib/src/gantt_chart_widget.dart
import 'package:flutter/material.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/services.dart';
import 'package:flutter/foundation.dart';
import 'package:legacy_gantt_chart/src/models/legacy_gantt_dependency.dart';
import 'package:flutter/scheduler.dart';
import 'package:provider/provider.dart';
import 'models/legacy_gantt_task.dart';
import 'models/legacy_gantt_theme.dart';
import 'models/legacy_gantt_row.dart';
import 'axis_painter.dart';
import 'legacy_gantt_controller.dart';
import 'legacy_gantt_view_model.dart';
import 'bars_collection_painter.dart';

/// Defines the type of progress indicator to display during loading.
enum GanttLoadingIndicatorType {
  /// A circular progress indicator in the center of the chart.
  circular,

  /// A linear progress indicator at the top or bottom of the chart.
  linear,
}

/// Defines the position for the linear progress indicator.
enum GanttLoadingIndicatorPosition {
  /// Positions the linear indicator at the top of the chart area.
  top,

  /// Positions the linear indicator at the bottom of the chart area.
  bottom,
}

/// The main widget for displaying a Gantt chart.
///
/// This widget is responsible for rendering the timeline, task bars, and dependencies.
/// It handles user interactions such as dragging, resizing, and creating tasks and dependencies.
///
/// It can be used with a static list of data or dynamically with a [LegacyGanttController].
class LegacyGanttChartWidget extends StatefulWidget {
  /// The list of [LegacyGanttTask] objects to display on the chart.
  /// This is ignored if a [controller] or [tasksFuture] is provided.
  final List<LegacyGanttTask>? data;

  /// A list of dependencies to draw between tasks.
  /// This is ignored if a [controller] is provided.
  final List<LegacyGanttTaskDependency>? dependencies;

  /// A list of conflict indicators to draw on the chart. These are typically
  /// generated by a conflict detection algorithm.
  final List<LegacyGanttTask>? conflictIndicators;

  /// A list of tasks to be rendered as background highlights, such as holidays
  /// or weekends. These tasks should have `isTimeRangeHighlight` set to `true`.
  /// This is ignored if a [controller] is provided.
  final List<LegacyGanttTask>? holidays;

  /// The list of [LegacyGanttRow]s that are currently visible in the chart's viewport.
  /// This is used to determine which rows to render.
  final List<LegacyGanttRow> visibleRows;

  /// A callback function invoked when the user's cursor hovers over a task.
  ///
  /// Provides the [LegacyGanttTask] being hovered and the global position of the cursor.
  /// Useful for showing custom tooltips or hover effects.
  final Function(LegacyGanttTask?, Offset globalPosition)? onTaskHover;

  /// A scroll controller for the vertical scrolling of the Gantt chart.
  ///
  /// This should be the same controller used by an accompanying data grid (e.g., `GanttGrid`)
  /// to ensure that the chart and the grid scroll in sync.
  final ScrollController? scrollController;

  /// The height of the timeline axis header at the top of the chart.
  final double? axisHeight;

  /// Defines the height of each row based on task overlaps.
  ///
  /// This map keys a [LegacyGanttRow.id] to an integer representing the maximum
  /// number of concurrent tasks to display vertically in that row.
  ///
  /// * **Calculation:** The total height for a given row is calculated as
  ///   `rowHeight * rowMaxStackDepth[rowId]`.
  /// * **Conflicts:** If more tasks overlap than this value allows, the chart
  ///   will render a conflict indicator (a red, patterned bar) if `showConflicts` is enabled.
  final Map<String, int> rowMaxStackDepth;

  /// The height of a single task bar lane within a row. The total height of a
  /// [LegacyGanttRow] is `rowHeight * stackDepth`.
  final double rowHeight;

  /// The theme data that defines the colors and styles for the chart's elements.
  /// If not provided, a default theme is derived from the ambient [ThemeData].
  final LegacyGanttTheme? theme;

  /// The start of the visible date range, expressed as milliseconds since the Unix epoch.
  ///
  /// This determines the leftmost edge of the chart's viewport.
  /// * If a [controller] is provided, this property is ignored as the controller manages the viewport.
  /// * If [gridMin] is null and no controller is used, the chart defaults to the earliest start date found in [data].
  final double? gridMin;

  /// The end of the visible date range, expressed as milliseconds since the Unix epoch.
  ///
  /// This determines the rightmost edge of the chart's viewport.
  /// * If a [controller] is provided, this property is ignored as the controller manages the viewport.
  /// * If [gridMax] is null and no controller is used, the chart defaults to the latest end date found in [data].
  final double? gridMax;

  /// The absolute start of the entire possible date range for the chart.
  /// This is used by the timeline axis to determine its overall width.
  final double? totalGridMin; // The start of the entire dataset's time range

  /// The absolute end of the entire possible date range for the chart.
  final double? totalGridMax; // The end of the entire dataset's time range

  /// A callback function invoked when a user taps or clicks on a task bar.
  final Function(LegacyGanttTask)? onPressTask;

  /// Enables or disables the ability to drag and drop tasks to change their time or row.
  final bool enableDragAndDrop;

  /// Enables or disables the ability to resize tasks by dragging their start or end handles.
  final bool enableResize;

  /// A future that resolves to the list of tasks to display.
  /// This is ignored if a [controller] is provided.
  final Future<List<LegacyGanttTask>>? tasksFuture;

  /// A future that resolves to a list of holiday/highlight tasks.
  /// This is ignored if a [controller] is provided.
  final Future<List<LegacyGanttTask>>? holidaysFuture;

  /// A controller to programmatically manage the Gantt chart's state, including
  /// the visible date range and dynamically loaded data. When a controller is
  /// provided, properties like `data`, `holidays`, `gridMin`, and `gridMax` are
  /// ignored as they are managed by the controller.
  final LegacyGanttController? controller;

  /// A builder function to create a completely custom widget for a task bar.
  ///
  /// If this is provided, the default task bar painting is skipped, and this widget is
  /// rendered instead. This gives full control over the appearance and behavior of a task.
  /// This cannot be used simultaneously with [taskContentBuilder].
  final Widget Function(LegacyGanttTask task)? taskBarBuilder;

  /// A builder to create custom content *inside* the default task bar.
  ///
  /// This is useful for adding custom icons, text, or progress indicators while
  /// retaining the default bar's shape, color, and drag/resize handles.
  /// This cannot be used simultaneously with [taskBarBuilder].
  final Widget Function(LegacyGanttTask task)? taskContentBuilder;

  /// A callback function that is invoked when a task is updated through dragging or resizing.
  ///
  /// Provides the updated [LegacyGanttTask] and its new `start` and `end` times.
  final Function(LegacyGanttTask task, DateTime newStart, DateTime newEnd)? onTaskUpdate;

  /// A callback function invoked when a user double-taps or double-clicks on a task bar.
  ///
  /// Provides the [LegacyGanttTask] that was double-tapped.
  final Function(LegacyGanttTask task)? onTaskDoubleClick;

  /// A callback function that is invoked when a task is deleted.
  final Function(LegacyGanttTask task)? onTaskDelete;

  /// A function to format the date/time shown in the tooltip when resizing a task.
  final String Function(DateTime)? resizeTooltipDateFormat;

  /// A callback that is triggered when a user clicks on an empty space in the
  /// chart. This can be used to initiate the creation of a new task.
  final Function(String rowId, DateTime time)? onEmptySpaceClick;

  /// The background color of the tooltip that appears during drag or resize operations.
  /// If not provided, it defaults to the theme's `barColorPrimary`.
  final Color? resizeTooltipBackgroundColor;

  /// The font color of the tooltip that appears during drag or resize operations.
  /// If not provided, it's automatically determined for contrast against the
  /// tooltip's background color.
  final Color? resizeTooltipFontColor;

  /// The width of the resize handles at the start and end of a task bar.
  final double resizeHandleWidth;

  /// A builder function to customize the labels displayed on the timeline axis.
  ///
  /// This function is called for each label on the timeline and provides the
  /// [DateTime] of the label and the current [Duration] of the tick interval.
  /// This allows for flexible formatting, such as displaying month names,
  /// fiscal year quarters, or any other custom representation.
  ///
  /// Example:
  /// ```dart
  /// timelineAxisLabelBuilder: (DateTime date, Duration interval) {
  ///   if (interval.inDays > 20) {
  ///     return DateFormat('MMM yyyy').format(date); // Display month and year
  ///   } else {
  ///     return DateFormat('d MMM').format(date); // Display day and month
  ///   }
  /// }
  /// ```
  final String Function(DateTime, Duration)? timelineAxisLabelBuilder;

  /// A builder function to create a completely custom widget for the timeline header.
  ///
  /// If this is provided, the default timeline header painting is skipped, and this
  /// widget is rendered instead. This gives you full control over the appearance
  /// and behavior of the timeline header.
  ///
  /// The builder provides the following arguments:
  /// - `context`: The build context.
  /// - `scale`: A function that converts a `DateTime` to its corresponding horizontal (x-axis) pixel value.
  /// - `visibleDomain`: The currently visible date range.
  /// - `totalDomain`: The total date range of the entire chart.
  /// - `theme`: The current Gantt chart theme.
  /// - `totalContentWidth`: The total width of the chart's content area.
  final Widget Function(
    BuildContext context,
    double Function(DateTime) scale,
    List<DateTime> visibleDomain,
    List<DateTime> totalDomain,
    LegacyGanttTheme theme,
    double totalContentWidth,
  )? timelineAxisHeaderBuilder;

  /// A builder function to create a custom widget to display when there is no data.
  ///
  /// If not provided, a default message will be shown.
  final Widget Function(BuildContext context)? noDataWidgetBuilder;

  /// If set to `true`, the chart will display the empty rows provided via
  /// [visibleRows] even when there are no tasks.
  ///
  /// Defaults to `false`, which shows the [noDataWidgetBuilder] or a default "No data to display" message.
  final bool showEmptyRows;

  /// An optional fixed height for the Gantt chart widget.
  ///
  /// If provided, the widget will render with this explicit height. This is
  /// particularly useful when placing the Gantt chart inside a `SingleChildScrollView`
  /// to make it vertically scrollable. The user is responsible for calculating
  /// the appropriate height based on the number of rows and their content.
  ///
  /// If `null`, the widget will attempt to size itself based on the available
  /// constraints, either expanding to fill a parent (like `Expanded`) or
  /// calculating its intrinsic height if given unconstrained vertical space.
  final double? height;

  /// The type of progress indicator to display when loading data with a [controller].
  ///
  /// Defaults to [GanttLoadingIndicatorType.circular].
  final GanttLoadingIndicatorType loadingIndicatorType;

  /// The position of the [GanttLoadingIndicatorType.linear] progress indicator.
  ///
  /// This is only applicable if [loadingIndicatorType] is set to
  /// [GanttLoadingIndicatorType.linear].
  /// Defaults to [GanttLoadingIndicatorPosition.top].
  final GanttLoadingIndicatorPosition loadingIndicatorPosition;

  /// The height of the loading indicator when using [GanttLoadingIndicatorType.linear].
  /// Defaults to `4.0`.
  final double loadingIndicatorHeight;

  /// The days of the week to be highlighted as weekends.
  ///
  /// This list should contain integers representing the days of the week,
  /// where Monday is 1 and Sunday is 7.
  /// Defaults to [DateTime.saturday] and [DateTime.sunday].
  final List<int> weekendDays;

  /// The color used to highlight weekends in the chart background.
  ///
  /// If not provided, it defaults to a semi-transparent shade of the
  /// theme's `onSurface` color.
  final Color? weekendColor;

  /// A scroll controller for the horizontal scrolling of the Gantt chart.
  /// This is used internally to allow programmatic scrolling, for example,
  /// to bring a focused task into view.
  final ScrollController? horizontalScrollController;

  /// A callback invoked when an action (like focusing a task via keyboard)
  /// requires a row to become visible (e.g., by expanding a collapsed parent).
  /// The consumer of this widget is responsible for updating its state to make the row visible.
  final Function(String rowId)? onRowRequestVisible;

  /// The ID of the task that currently has keyboard focus.
  final String? focusedTaskId;

  /// A callback invoked when the focused task changes due to user interaction.
  final Function(String? taskId)? onFocusChange;

  /// A builder function to create custom resize handles that appear next to a focused task.
  ///
  /// The builder provides the `task` and a `part` enum (`TaskPart.startHandle` or `TaskPart.endHandle`)
  /// to allow for different widgets for the start and end handles. If this is `null`, no
  /// external handles are shown for focused tasks.
  final Widget Function(LegacyGanttTask task, TaskPart part, LegacyGanttViewModel vm, double handleWidth)?
      focusedTaskResizeHandleBuilder;

  /// The width of the floating resize handles that appear on a focused task.
  /// This value is passed to the [focusedTaskResizeHandleBuilder]. Defaults to `24.0`.
  final double focusedTaskResizeHandleWidth;

  const LegacyGanttChartWidget({
    super.key, // Use super.key
    this.data,
    this.dependencies,
    this.conflictIndicators,
    this.holidays,
    required this.visibleRows,
    required this.rowMaxStackDepth,
    this.onTaskHover,
    this.scrollController,
    this.axisHeight,
    this.rowHeight = 27.0,
    this.onPressTask,
    this.theme,
    this.gridMin,
    this.gridMax,
    this.totalGridMin,
    this.totalGridMax,
    this.enableDragAndDrop = false,
    this.enableResize = false,
    this.tasksFuture,
    this.holidaysFuture,
    this.controller,
    this.taskBarBuilder,
    this.taskContentBuilder,
    this.onTaskUpdate,
    this.onTaskDoubleClick,
    this.onTaskDelete,
    this.resizeTooltipDateFormat,
    this.onEmptySpaceClick,
    this.resizeTooltipBackgroundColor,
    this.resizeTooltipFontColor,
    this.resizeHandleWidth = 10.0,
    this.timelineAxisLabelBuilder,
    this.timelineAxisHeaderBuilder,
    this.noDataWidgetBuilder,
    this.showEmptyRows = false,
    this.height,
    this.loadingIndicatorType = GanttLoadingIndicatorType.circular,
    this.loadingIndicatorPosition = GanttLoadingIndicatorPosition.top,
    this.loadingIndicatorHeight = 4.0,
    this.weekendDays = const [DateTime.saturday, DateTime.sunday],
    this.weekendColor,
    this.onRowRequestVisible,
    this.focusedTaskId,
    this.onFocusChange,
    this.horizontalScrollController,
    this.focusedTaskResizeHandleBuilder,
    this.focusedTaskResizeHandleWidth = 24.0,
  })  : assert(controller != null || ((data != null && tasksFuture == null) || (data == null && tasksFuture != null))),
        assert(controller == null || dependencies == null),
        assert(taskBarBuilder == null || taskContentBuilder == null),
        assert(controller == null || conflictIndicators == null),
        assert(controller == null ||
            (data == null &&
                tasksFuture == null &&
                holidays == null &&
                holidaysFuture == null &&
                gridMin == null &&
                gridMax == null));

  @override
  State<LegacyGanttChartWidget> createState() => _LegacyGanttChartWidgetState();
}

class _LegacyGanttChartWidgetState extends State<LegacyGanttChartWidget> {
  // A direct reference to the internal view model is needed to push updates
  // when the widget's properties change.
  LegacyGanttViewModel? _internalViewModel;

  @override
  void didUpdateWidget(covariant LegacyGanttChartWidget oldWidget) {
    super.didUpdateWidget(oldWidget);

    // If the dependencies list has changed, push the update to the internal view model.
    // This is crucial for seeing new dependencies appear without a full rebuild.
    if (_internalViewModel != null && !listEquals(oldWidget.dependencies, widget.dependencies)) {
      // The list from the main view model is now passed down to the internal one.
      _internalViewModel!.updateDependencies(widget.dependencies ?? []);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final LegacyGanttTheme effectiveTheme =
        (widget.theme ?? LegacyGanttTheme.fromTheme(theme)).copyWith(weekendColor: widget.weekendColor);

    if (widget.controller != null) {
      return AnimatedBuilder(
        animation: widget.controller!,
        builder: (context, child) {
          final controller = widget.controller!;
          final tasks = controller.tasks;
          final holidays = controller.holidays;
          final dependencies = controller.dependencies;
          final conflictIndicators = controller.conflictIndicators;
          final allItems = [...tasks, ...holidays]; // Conflicts are handled separately

          if (controller.isOverallLoading && allItems.isEmpty && !widget.showEmptyRows) {
            if (widget.loadingIndicatorType == GanttLoadingIndicatorType.circular) {
              return const Center(child: CircularProgressIndicator());
            } else {
              return SizedBox(height: widget.loadingIndicatorHeight, child: const LinearProgressIndicator());
            }
          }

          if (allItems.isEmpty && !controller.isOverallLoading && !widget.showEmptyRows) {
            if (widget.noDataWidgetBuilder != null) {
              return widget.noDataWidgetBuilder!(context);
            } else {
              return Center(
                child: Text('No data to display.', style: TextStyle(color: effectiveTheme.textColor)),
              );
            }
          }

          return Stack(
            children: [
              _buildChart(
                context,
                allItems,
                dependencies,
                conflictIndicators,
                effectiveTheme,
                gridMin: controller.visibleStartDate.millisecondsSinceEpoch.toDouble(),
                gridMax: controller.visibleEndDate.millisecondsSinceEpoch.toDouble(),
              ),
              if (controller.isLoading && widget.loadingIndicatorType == GanttLoadingIndicatorType.linear)
                Positioned(
                  left: 0,
                  right: 0,
                  top: widget.loadingIndicatorPosition == GanttLoadingIndicatorPosition.top ? 0 : null,
                  bottom: widget.loadingIndicatorPosition == GanttLoadingIndicatorPosition.bottom ? 0 : null,
                  child: SizedBox(height: widget.loadingIndicatorHeight, child: const LinearProgressIndicator()),
                ),
              if (controller.isLoading && widget.loadingIndicatorType == GanttLoadingIndicatorType.circular)
                Positioned.fill(
                  child: Container(
                    color: effectiveTheme.backgroundColor.withValues(alpha: 0.5),
                    child: const Center(child: CircularProgressIndicator()),
                  ),
                ),
            ],
          );
        },
      );
    }

    if (widget.tasksFuture != null || widget.holidaysFuture != null) {
      return FutureBuilder<List<dynamic>>(
        future: Future.wait([
          widget.tasksFuture ?? Future.value(<LegacyGanttTask>[]),
          widget.holidaysFuture ?? Future.value(<LegacyGanttTask>[])
        ]),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }
          if (snapshot.hasError) {
            return Center(child: Text('Error: ${snapshot.error}'));
          }
          final tasks = (snapshot.data?[0] as List<LegacyGanttTask>?) ?? [];
          final holidays = (snapshot.data?[1] as List<LegacyGanttTask>?) ?? [];
          final allItems = [...tasks, ...holidays];
          // Conflicts are derived from tasks, so we pass them separately.
          final conflictIndicators = widget.conflictIndicators ?? [];
          if (allItems.isEmpty && !widget.showEmptyRows) {
            if (widget.noDataWidgetBuilder != null) {
              return widget.noDataWidgetBuilder!(context);
            } else {
              return Center(
                child: Text('No data to display.', style: TextStyle(color: effectiveTheme.textColor)),
              );
            }
          }
          return _buildChart(context, allItems, widget.dependencies ?? [], conflictIndicators, effectiveTheme);
        },
      );
    } else {
      final tasks = widget.data ?? [];
      final holidays = widget.holidays ?? [];
      final conflictIndicators = widget.conflictIndicators ?? [];
      final allItems = [...tasks, ...holidays];
      if (allItems.isEmpty && !widget.showEmptyRows) {
        if (widget.noDataWidgetBuilder != null) {
          return widget.noDataWidgetBuilder!(context);
        } else {
          return Center(
            child: Text('No data to display.', style: TextStyle(color: effectiveTheme.textColor)),
          );
        }
      }
      return _buildChart(context, allItems, widget.dependencies ?? [], conflictIndicators, effectiveTheme);
    }
  }

  Widget _buildChart(BuildContext context, List<LegacyGanttTask> tasks, List<LegacyGanttTaskDependency> dependencies,
          List<LegacyGanttTask> conflictIndicators, LegacyGanttTheme effectiveTheme, //
          {double? gridMin,
          double? gridMax}) =>
      ChangeNotifierProvider<LegacyGanttViewModel>(
        key: ValueKey(Object.hashAll([...tasks, ...widget.visibleRows])),
        create: (context) {
          // Create the view model and store a reference to it.
          _internalViewModel = LegacyGanttViewModel(
            data: tasks,
            conflictIndicators: conflictIndicators,
            dependencies: dependencies,
            visibleRows: widget.visibleRows,
            rowMaxStackDepth: widget.rowMaxStackDepth,
            rowHeight: widget.rowHeight,
            axisHeight: widget.axisHeight,
            gridMin: gridMin ?? widget.gridMin,
            gridMax: gridMax ?? widget.gridMax,
            totalGridMin: widget.totalGridMin,
            totalGridMax: widget.totalGridMax,
            enableDragAndDrop: widget.enableDragAndDrop,
            enableResize: widget.enableResize,
            onTaskUpdate: widget.onTaskUpdate,
            onTaskDoubleClick: widget.onTaskDoubleClick,
            onTaskDelete: widget.onTaskDelete,
            onEmptySpaceClick: widget.onEmptySpaceClick,
            onPressTask: widget.onPressTask,
            onTaskHover: widget.onTaskHover,
            taskBarBuilder: widget.taskBarBuilder,
            resizeTooltipDateFormat: widget.resizeTooltipDateFormat, // The external controller to LISTEN to
            scrollController: widget.scrollController, // The external controller to LISTEN to
            ganttHorizontalScrollController: widget.horizontalScrollController,
            onRowRequestVisible: widget.onRowRequestVisible,
            initialFocusedTaskId: widget.focusedTaskId,
            onFocusChange: widget.onFocusChange,
            resizeHandleWidth: widget.resizeHandleWidth,
          );
          return _internalViewModel!;
        },
        child: Consumer<LegacyGanttViewModel>(
          builder: (context, vm, child) {
            SchedulerBinding.instance.addPostFrameCallback((_) {
              vm.updateVisibleRange(gridMin ?? widget.gridMin, gridMax ?? widget.gridMax);
              vm.updateFocusedTask(widget.focusedTaskId);
              vm.updateResizeTooltipDateFormat(widget.resizeTooltipDateFormat); // Call the new method here
            });

            return LayoutBuilder(
              builder: (BuildContext context, BoxConstraints constraints) {
                if (constraints.maxWidth == 0 || constraints.maxHeight == 0) {
                  return const SizedBox.shrink();
                }

                vm.updateLayout(constraints.maxWidth, constraints.maxHeight);

                final double totalContentWidth =
                    vm.totalDomain.isEmpty ? constraints.maxWidth : vm.totalScale(vm.totalDomain.last);

                // This is the intrinsically calculated height of the content, excluding the timeline axis.

                final double totalContentHeight =
                    (widget.showEmptyRows ? widget.visibleRows.map((r) => r.id) : tasks.map((t) => t.rowId))
                        .toSet()
                        .fold<double>(
                          0.0,
                          (prev, rowId) => prev + widget.rowHeight * (widget.rowMaxStackDepth[rowId] ?? 1),
                        );

                final bool useIntrinsicHeight = !constraints.maxHeight.isFinite;

                // Determine the final height of the chart widget.

                final double chartHeight;

                if (widget.height != null) {
                  // 1. If an explicit height is provided, always use it.

                  chartHeight = widget.height!;
                } else if (useIntrinsicHeight) {
                  // 2. If in an unconstrained environment (like a SingleChildScrollView),

                  //    calculate the intrinsic height.

                  chartHeight = vm.timeAxisHeight + totalContentHeight;
                } else {
                  // 3. Otherwise, expand to fill the available constrained space.

                  chartHeight = constraints.maxHeight;
                }

                // The height of the actual bar area (excluding the timeline axis).

                final double contentHeight = chartHeight - vm.timeAxisHeight;

                return FocusableActionDetector(
                    autofocus: true,
                    shortcuts: {
                      LogicalKeySet(LogicalKeyboardKey.tab): const NextFocusIntent(),
                      LogicalKeySet(LogicalKeyboardKey.shift, LogicalKeyboardKey.tab): const PreviousFocusIntent(),
                    },
                    actions: {
                      NextFocusIntent: CallbackAction<NextFocusIntent>(onInvoke: (intent) {
                        final focusableTasks =
                            tasks.where((t) => !t.isTimeRangeHighlight && !t.isOverlapIndicator).toList();
                        if (focusableTasks.isEmpty) return;

                        final currentIdx = focusableTasks.indexWhere((t) => t.id == vm.focusedTaskId);
                        if (currentIdx == -1) {
                          vm.setFocusedTask(focusableTasks.first.id);
                        } else {
                          final nextIdx = (currentIdx + 1) % focusableTasks.length;
                          vm.setFocusedTask(focusableTasks[nextIdx].id);
                        }
                        return null;
                      }),
                      PreviousFocusIntent: CallbackAction<PreviousFocusIntent>(onInvoke: (intent) {
                        final focusableTasks =
                            tasks.where((t) => !t.isTimeRangeHighlight && !t.isOverlapIndicator).toList();
                        if (focusableTasks.isEmpty) return;

                        final currentIdx = focusableTasks.indexWhere((t) => t.id == vm.focusedTaskId);
                        if (currentIdx <= 0) {
                          vm.setFocusedTask(focusableTasks.last.id);
                        } else {
                          final prevIdx = currentIdx - 1;
                          vm.setFocusedTask(focusableTasks[prevIdx].id);
                        }
                        return null;
                      }),
                    },
                    child: MouseRegion(
                      cursor: vm.cursor,
                      onHover: vm.onHover,
                      onExit: vm.onHoverExit,
                      child: RawGestureDetector(
                        gestures: {
                          _AllowMultipleHorizontalDragGestureRecognizer:
                              GestureRecognizerFactoryWithHandlers<_AllowMultipleHorizontalDragGestureRecognizer>(
                            () => _AllowMultipleHorizontalDragGestureRecognizer(),
                            (instance) {
                              instance
                                ..onStart = vm.onPanStart
                                ..onUpdate = vm.onPanUpdate
                                ..onEnd = vm.onPanEnd;
                            },
                          ),
                          TapGestureRecognizer: GestureRecognizerFactoryWithHandlers<TapGestureRecognizer>(
                              () => TapGestureRecognizer()..onTapUp = vm.onTapUp, (instance) {}),
                          DoubleTapGestureRecognizer: GestureRecognizerFactoryWithHandlers<DoubleTapGestureRecognizer>(
                              () => DoubleTapGestureRecognizer()
                                ..onDoubleTapDown = (details) => vm.onDoubleTap(details.localPosition),
                              (instance) {}),
                        },
                        child: Container(
                          color: effectiveTheme.backgroundColor,
                          height: chartHeight,
                          child: Stack(
                            children: [
                              Positioned.fill(
                                child: CustomPaint(
                                  painter: AxisPainter(
                                    x: 0,
                                    y: vm.timeAxisHeight,
                                    width: totalContentWidth,
                                    height: contentHeight,
                                    scale: vm.totalScale,
                                    domain: vm.totalDomain,
                                    visibleDomain: vm.visibleExtent,
                                    theme: effectiveTheme.copyWith(
                                        axisTextStyle: const TextStyle(color: Colors.transparent)),
                                    weekendColor: effectiveTheme.weekendColor,
                                    weekendDays: widget.weekendDays,
                                  ),
                                ),
                              ),
                              Positioned(
                                top: vm.timeAxisHeight,
                                left: 0,
                                width: constraints.maxWidth,
                                height: contentHeight,
                                child: ClipRect(
                                  child: Stack(
                                    children: [
                                      CustomPaint(
                                        painter: BarsCollectionPainter(
                                          conflictIndicators: vm.conflictIndicators,
                                          dependencies: vm.dependencies,
                                          data: tasks,
                                          domain: vm.totalDomain,
                                          visibleRows: widget.visibleRows,
                                          rowMaxStackDepth: widget.rowMaxStackDepth,
                                          scale: vm.totalScale,
                                          rowHeight: widget.rowHeight,
                                          draggedTaskId: vm.draggedTask?.id,
                                          ghostTaskStart: vm.ghostTaskStart,
                                          ghostTaskEnd: vm.ghostTaskEnd,
                                          theme: effectiveTheme,
                                          hoveredRowId: vm.hoveredRowId,
                                          hoveredDate: vm.hoveredDate,
                                          hasCustomTaskBuilder: widget.taskBarBuilder != null,
                                          hasCustomTaskContentBuilder: widget.taskContentBuilder != null,
                                          translateY: vm.translateY,
                                        ),
                                        size: Size(totalContentWidth, totalContentHeight),
                                      ),
                                      ..._buildTaskWidgets(vm, tasks, effectiveTheme),
                                      ..._buildCustomCellWidgets(vm, tasks),
                                      if (vm.focusedTaskId != null)
                                        ..._buildFocusedTaskWidgets(vm, tasks, effectiveTheme,
                                            widget.focusedTaskResizeHandleBuilder, widget.focusedTaskResizeHandleWidth),
                                    ],
                                  ),
                                ),
                              ),
                              Positioned(
                                top: 0,
                                left: 0,
                                width: totalContentWidth,
                                height: vm.timeAxisHeight,
                                child: ClipRect(
                                  child: Container(
                                    color: effectiveTheme.backgroundColor,
                                    child: widget.timelineAxisHeaderBuilder != null
                                        ? widget.timelineAxisHeaderBuilder!(
                                            context,
                                            vm.totalScale,
                                            vm.visibleExtent,
                                            vm.totalDomain,
                                            effectiveTheme,
                                            totalContentWidth,
                                          )
                                        : CustomPaint(
                                            size: Size(totalContentWidth, vm.timeAxisHeight),
                                            painter: AxisPainter(
                                              x: 0,
                                              y: vm.timeAxisHeight / 2,
                                              width: totalContentWidth,
                                              height: 0,
                                              scale: vm.totalScale,
                                              domain: vm.totalDomain,
                                              visibleDomain: vm.visibleExtent,
                                              theme: effectiveTheme,
                                              timelineAxisLabelBuilder: widget.timelineAxisLabelBuilder,
                                              weekendColor: effectiveTheme.weekendColor,
                                              weekendDays: widget.weekendDays,
                                            ),
                                          ),
                                  ),
                                ),
                              ),
                              if (vm.showResizeTooltip)
                                Positioned(
                                  left: vm.resizeTooltipPosition.dx + 15,
                                  top: vm.resizeTooltipPosition.dy + 15,
                                  child: _buildResizeTooltip(context, vm.resizeTooltipText, effectiveTheme),
                                ),
                            ],
                          ),
                        ),
                      ),
                    ));
              },
            );
          },
        ),
      );

  Widget _buildResizeTooltip(BuildContext context, String text, LegacyGanttTheme theme) {
    final tooltipBackgroundColor = widget.resizeTooltipBackgroundColor ?? theme.barColorPrimary;
    final tooltipFontColor = widget.resizeTooltipFontColor ??
        (ThemeData.estimateBrightnessForColor(tooltipBackgroundColor) == Brightness.dark ? Colors.white : Colors.black);

    return Material(
      elevation: 4.0,
      borderRadius: BorderRadius.circular(4),
      color: Colors.transparent,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 10.0, vertical: 6.0),
        decoration: BoxDecoration(color: tooltipBackgroundColor, borderRadius: BorderRadius.circular(4)),
        child: Text(
          text,
          style: theme.axisTextStyle.copyWith(color: tooltipFontColor),
        ),
      ),
    );
  }

  List<Widget> _buildTaskWidgets(LegacyGanttViewModel vm, List<LegacyGanttTask> tasks, LegacyGanttTheme theme) {
    final List<Widget> taskWidgets = [];
    double cumulativeRowTop = 0;

    final Map<String, List<LegacyGanttTask>> tasksByRow = {};
    final visibleRowIds = vm.visibleRows.map((r) => r.id).toSet();
    for (final task in tasks) {
      if (visibleRowIds.contains(task.rowId) && !task.isTimeRangeHighlight) {
        tasksByRow.putIfAbsent(task.rowId, () => []).add(task);
      }
    }

    for (final rowData in vm.visibleRows) {
      final tasksInThisRow = tasksByRow[rowData.id] ?? [];
      for (final task in tasksInThisRow) {
        final startX = vm.totalScale(task.start);
        final endX = vm.totalScale(task.end);
        final width = endX - startX;

        if (width <= 0) {
          continue;
        }

        final top = cumulativeRowTop + (task.stackIndex * vm.rowHeight) + vm.translateY;

        Widget taskWidget;
        if (task.isOverlapIndicator) {
          taskWidget = _OverlapIndicatorBar(theme: theme);
        } else if (widget.taskBarBuilder != null) {
          taskWidget = widget.taskBarBuilder!(task);
        } else {
          taskWidget = _DefaultTaskBar(
            task: task,
            vm: vm,
            theme: theme,
            content: widget.taskContentBuilder != null ? widget.taskContentBuilder!(task) : null,
          );
        }

        taskWidgets.add(Positioned(
          left: startX,
          top: top,
          width: width,
          height: vm.rowHeight,
          child: taskWidget,
        ));
      }
      final stackDepth = vm.rowMaxStackDepth[rowData.id] ?? 1;
      cumulativeRowTop += vm.rowHeight * stackDepth;
    }
    return taskWidgets;
  }

  List<Widget> _buildCustomCellWidgets(LegacyGanttViewModel vm, List<LegacyGanttTask> tasks) {
    final List<Widget> customCells = [];
    double cumulativeRowTop = 0;

    final Map<String, List<LegacyGanttTask>> tasksByRow = {};
    final visibleRowIds = vm.visibleRows.map((r) => r.id).toSet();
    for (final task in tasks) {
      if (visibleRowIds.contains(task.rowId) && task.cellBuilder != null) {
        tasksByRow.putIfAbsent(task.rowId, () => []).add(task);
      }
    }

    for (final rowData in vm.visibleRows) {
      final tasksInThisRow = tasksByRow[rowData.id] ?? [];
      for (final task in tasksInThisRow) {
        final taskStart = task.start;
        final taskEnd = task.end;

        var currentDate = DateTime(taskStart.year, taskStart.month, taskStart.day);
        while (currentDate.isBefore(taskEnd)) {
          final segmentStart = taskStart.isAfter(currentDate) ? taskStart : currentDate;
          final nextDay = currentDate.add(const Duration(days: 1));
          final segmentEnd = taskEnd.isBefore(nextDay) ? taskEnd : nextDay;

          final startX = vm.totalScale(segmentStart);
          final endX = vm.totalScale(segmentEnd);
          final width = endX - startX;

          if (width > 0) {
            final top = cumulativeRowTop + (task.stackIndex * vm.rowHeight) + vm.translateY;
            customCells.add(Positioned(
                left: startX, top: top, width: width, height: vm.rowHeight, child: task.cellBuilder!(currentDate)));
          }
          currentDate = nextDay;
        }
      }
      final stackDepth = vm.rowMaxStackDepth[rowData.id] ?? 1;
      cumulativeRowTop += vm.rowHeight * stackDepth;
    }
    return customCells;
  }
}

List<Widget> _buildFocusedTaskWidgets(
  LegacyGanttViewModel vm,
  List<LegacyGanttTask> tasks,
  LegacyGanttTheme theme,
  Widget Function(LegacyGanttTask, TaskPart, LegacyGanttViewModel, double)? handleBuilder,
  double handleWidth,
) {
  if (vm.focusedTaskId == null) return [];

  final focusedTask = tasks.firstWhere((t) => t.id == vm.focusedTaskId, orElse: () => LegacyGanttTask.empty());
  if (focusedTask.id.isEmpty) return [];

  // Find the row index and its vertical offset.
  final rowIndex = vm.visibleRows.indexWhere((r) => r.id == focusedTask.rowId);
  if (rowIndex == -1) return [];

  final rowTop = vm.getRowVerticalOffset(rowIndex);
  if (rowTop == null) return [];

  final startX = vm.totalScale(focusedTask.start);
  final endX = vm.totalScale(focusedTask.end);
  final width = endX - startX;
  final top = rowTop + (focusedTask.stackIndex * vm.rowHeight) + vm.translateY;

  final List<Widget> widgets = [
    Positioned(
      left: startX,
      top: top,
      width: width,
      height: vm.rowHeight,
      child: Container(
        decoration: BoxDecoration(
          border: Border.all(color: theme.barColorSecondary, width: 2),
          borderRadius: BorderRadius.circular(4.0),
        ),
      ),
    )
  ];

  // Add custom resize handles if a builder is provided
  if (handleBuilder != null) {
    final startHandle = handleBuilder(focusedTask, TaskPart.startHandle, vm, handleWidth);
    final endHandle = handleBuilder(focusedTask, TaskPart.endHandle, vm, handleWidth);

    widgets.addAll([
      Positioned(
        left: startX - handleWidth,
        top: top,
        height: vm.rowHeight,
        child: startHandle,
      ),
      Positioned(
        left: endX,
        top: top,
        height: vm.rowHeight,
        child: endHandle,
      ),
    ]);
  }

  return widgets;
}

class _DefaultTaskBar extends StatefulWidget {
  final LegacyGanttTask task;
  final LegacyGanttViewModel vm;
  final LegacyGanttTheme theme;
  final Widget? content;

  const _DefaultTaskBar({
    required this.task,
    required this.vm,
    required this.theme,
    this.content,
  });

  @override
  _DefaultTaskBarState createState() => _DefaultTaskBarState();
}

class _DefaultTaskBarState extends State<_DefaultTaskBar> {
  bool _isHovered = false;
  final FocusNode _focusNode = FocusNode();

  @override
  void dispose() {
    _focusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final task = widget.task;
    final theme = widget.theme;
    final vm = widget.vm;
    return Focus(
      focusNode: _focusNode,
      onFocusChange: (hasFocus) {
        if (hasFocus) {
          vm.setFocusedTask(task.id);
        }
      },
      child: MouseRegion(
        onEnter: (_) => setState(() => _isHovered = true),
        onExit: (_) => setState(() => _isHovered = false),
        child: Container(
          decoration: BoxDecoration(
            color: Colors.transparent,
            borderRadius: BorderRadius.circular(4.0),
          ),
          child: Stack(
            fit: StackFit.expand,
            children: [
              if (widget.content != null) widget.content!,
              if (_isHovered && vm.onTaskDelete != null)
                Positioned(
                  right: 0,
                  top: 0,
                  bottom: 0,
                  child: IconButton(
                    icon: const Icon(Icons.close, size: 16),
                    color: theme.taskTextStyle.color,
                    onPressed: () => vm.deleteTask(task),
                    splashRadius: 16,
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

/// A custom gesture recognizer that allows multiple horizontal drag gesture
/// recognizers to compete and win simultaneously. This is crucial for allowing
/// both the inner Gantt chart's task drag/resize and the outer `SingleChildScrollView`'s
/// scroll to be recognized.
class _AllowMultipleHorizontalDragGestureRecognizer extends HorizontalDragGestureRecognizer {
  @override
  void rejectGesture(int pointer) => acceptGesture(pointer);
}

/// A widget that uses a [CustomPainter] to draw the conflict/overlap pattern.
class _OverlapIndicatorBar extends StatelessWidget {
  final LegacyGanttTheme theme;

  const _OverlapIndicatorBar({required this.theme});

  @override
  Widget build(BuildContext context) => CustomPaint(
        painter: _OverlapPainter(theme: theme),
        child: Container(),
      );
}

/// The actual painter for the conflict/overlap pattern.
class _OverlapPainter extends CustomPainter {
  final LegacyGanttTheme theme;

  _OverlapPainter({required this.theme});

  @override
  void paint(Canvas canvas, Size size) {
    final barHeight = size.height * theme.barHeightRatio;
    final barVerticalCenterOffset = (size.height - barHeight) / 2;
    final fullRect = Rect.fromLTWH(0, barVerticalCenterOffset, size.width, barHeight);

    // Deflate the indicator to only show on the bottom 30% of the bar
    final indicatorHeight = fullRect.height * 0.4;
    final indicatorRect = Rect.fromLTWH(
      fullRect.left,
      fullRect.bottom - indicatorHeight,
      fullRect.width,
      indicatorHeight,
    );
    final indicatorRRect = RRect.fromRectAndRadius(indicatorRect, theme.barCornerRadius);

    // To ensure the conflict pattern is clear and not blended with underlying bars,
    // we first "erase" the area by drawing a solid block of the chart's background color.
    canvas.drawRRect(indicatorRRect, Paint()..color = theme.backgroundColor);

    // Next, draw the semi-transparent red background for the conflict area.
    final backgroundPaint = Paint()..color = theme.conflictBarColor.withValues(alpha: 0.4);
    canvas.drawRRect(indicatorRRect, backgroundPaint);

    // Then, draw the angled lines on top of that new background.
    _drawAngledPattern(canvas, indicatorRRect, theme.conflictBarColor, 1.0);
  }

  void _drawAngledPattern(Canvas canvas, RRect rrect, Color color, double strokeWidth) {
    final patternPaint = Paint()
      ..color = color
      ..strokeWidth = strokeWidth
      ..style = PaintingStyle.stroke;

    canvas.save();
    canvas.clipRRect(rrect);

    const double lineSpacing = 8.0;
    for (double i = -rrect.height; i < rrect.width; i += lineSpacing) {
      canvas.drawLine(
          Offset(rrect.left + i, rrect.top), Offset(rrect.left + i + rrect.height, rrect.bottom), patternPaint);
    }
    canvas.restore();
  }

  @override
  bool shouldRepaint(covariant _OverlapPainter oldDelegate) => oldDelegate.theme != theme;
}
